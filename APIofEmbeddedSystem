using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using System.Threading;
using System.IO;

namespace SerialPort
{
    ///----------------------------------------------------------------------
    ///FrmSCI  :串口测试工程+浮点数四则元算+Flash中图片读写                                                
    ///功能描述:1.测试串口通信是否正常                                                    
    ///           接收到的数据分别以字符串、十进制、十六进制三种方式显示 
    ///         2.在PC端与MCU端进行浮点数四则运算并运算结果显示出来
    ///         3.在KL25Flash中存储图片，并读出Flash中存储的图片
    ///目    的:1.测试串口 
    ///         2.测试PC与MCU端进行浮点数四则运算差别及
    ///           在串口通信中对数据进行组帧
    ///         3.在KL25Flash中存储图片，并读出Flash中存储的图片
    ///说    明:                                                           
    ///注    意:                                                           
    ///日    期:2015年6月5日                                              
    ///编 程 者:穆太力扑                                                     
    ///-----------串口测试工程(苏州大学飞思卡尔嵌入式中心)----------------------
    public partial class FrmSCI : Form
    {
        //委托,将从串口接收到的数据显示到接收框里面
        delegate void handleinterfaceupdatedelegate(Object textbox,
                                                    string text);

        //串口默认情况
        private string msg = "无校验,8位数据位,1位停止位(No parity,8 data " +
                            "bits,1 stop bit)";
        private string str = "串口号(Serial Port Number)、波特率(Baud Rate):";

        SCI sci = new SCI();    //要调用SCI类中所定义的函数

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 函 数 名:FrmSCI:类FrmSCI的构造函数                              
        /// 功    能:完成窗体的初始化工作                                   
        /// 函数调用:InitializeComponent                                    
        /// </summary>                                                      
        ///-----------------------------------------------------------------
        public FrmSCI()
        {
            InitializeComponent();
        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:FrmSCI:窗体                                            
        /// 事    件:Load                                                   
        /// 功    能:执行加载窗体程序,自动获得串口号                        
        ///          同时在标签LblSCI中显示串口相关信息                     
        /// 函数调用:无                                                     
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        /// <remarks></remarks>                                             
        ///-----------------------------------------------------------------
        int jpgLen;
        private void FrmSCI_Load(object sender, EventArgs e)
        {
            //初始化时,按钮显示"打开串口(Open SCI)"

            this.BtnSCISwitch.Text = "打开串口(Open SCI)";
            this.CbSCIBaud.Enabled = true;    //[波特率选择框]处于可用状态
            this.CbSCIComNum.Enabled = true;　//[串口选择框]处于可用状态

            //自动搜索串口,并将其加入到[串口选择框]中
            int i;
            string[] SCIPorts;
            SCIPorts = System.IO.Ports.SerialPort.GetPortNames();
            this.CbSCIComNum.Items.Clear();//首先将现有的项清除掉
            for (i = 0; i < SCIPorts.Length; i++)
                //向[串口选择框]中添加搜索到的串口号
                this.CbSCIComNum.Items.Add(SCIPorts[i]);

            //设置各组合框的初始显示值
            if (SCIPorts.Length != 0)
            {
                this.BtnSCISwitch.Enabled = true;
                this.CbSCIBaud.SelectedIndex = 0;
                this.CbSCIComNum.SelectedIndex = 0;
                //this.CbSCISendType.SelectedIndex = 0;

                //设置初始的串口号与波特率
                PublicVar.g_SCIComNum = this.CbSCIComNum.Text;
                PublicVar.g_SCIBaudRate = int.Parse(this.CbSCIBaud.Text);
                //显示当前串口信与状态信息
                this.LblSCI.Text = str + PublicVar.g_SCIComNum + "、" +
                                   PublicVar.g_SCIBaudRate + "\n" + msg;
                this.TSSLState.Text = "无操作,请先选择波特率与串口号,打开串口," +
                                 "然后发送数据";
            }
            else
            {
                this.TSSLState.Text = "没有可用的串口,请检查!";
                this.BtnSCISwitch.Enabled = false;
            }
            //this.pictureBox2.Image = Image.FromFile("D:\\1.jpg");
            jpgLen = PictureToByte("1.jpg").Length;
            byte[] picture_byte = new byte[jpgLen];
            picture_byte = PictureToByte("1.jpg");
            pictureBox2.Image = ByteToPicture(picture_byte);
            
        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:CbSCIBaud                                              
        /// 事    件:SelectedIndexChanged                                   
        /// 功    能:改变当前串口波特率                                     
        /// 函数调用:无                                                     
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///-----------------------------------------------------------------
        private void CbSCIBaud_SelectedIndexChanged(object sender,
                                                    EventArgs e)
        {
            PublicVar.g_SCIBaudRate = int.Parse(this.CbSCIBaud.Text);
            this.TSSLState.Text = "过程提示:选择波特率";
        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:CbSCIComNum:串口选择框                                 
        /// 事    件:SelectedIndexChanged                                  
        /// 功    能:改变当前串口号                                         
        /// 函数调用:无                                                     
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///-----------------------------------------------------------------
        private void CbSCIComNum_SelectedIndexChanged(object sender,
                                                      EventArgs e)
        {
            PublicVar.g_SCIComNum = this.CbSCIComNum.Text;
            this.TSSLState.Text = "过程提示:选择串口号";
        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:BtnSCISwitch                                           
        /// 事    件:Click                                                  
        /// 功    能:(1)当开关显示为打开串口(Open SCI),则单击时执行打开串口 
        ///          操作,并在标签LblSCI中显示选择的串口号与波特率,并在     
        ///          状态条文本TSSLState中显示当前操作                      
        ///          (2)当开关显示为关闭串口(Close SCI),则单击时执行关闭串口
        ///          操作,并在标签LblSCI中显示关闭的串口号与波特率,并在     
        ///          状态条文本TSSLState中显示当前操作                      
        /// 函数调用:(1)SCIInit:串口初始化                                  
        ///          (2)SCIClose:关闭串口                                   
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///-----------------------------------------------------------------
        private void BtnSCISwitch_Click(object sender, EventArgs e)
        {
            bool Flag;//标记打开是否成功
            //根据按钮BtnSCISwitch显示内容执行打开或关闭串口操作
            if (this.BtnSCISwitch.Text.CompareTo("打开串口(Open SCI)") == 0)
            {
                //提示当前正在执行打开串口操作
                this.TSSLState.Text = "过程提示:正在打开串口...";
                //进行串口的初始化,并用Flag返回结果
                Flag = sci.SCIInit(SCIPort, PublicVar.g_SCIComNum,
                            PublicVar.g_SCIBaudRate);

                if (Flag == true)//串口打开成功
                {
                    //显示打开串口相关信息
                    this.LblSCI.Text = str + PublicVar.g_SCIComNum +
                        "、" + PublicVar.g_SCIBaudRate + "\n" + msg;

                    this.BtnSCISwitch.Text = "关闭串口(Close SCI)";
                    //[串口选择框]处于禁用状态
                    this.CbSCIComNum.Enabled = false;
                    //[波特率选择框]处于禁用状态
                    this.CbSCIBaud.Enabled = false;
                    //状态上显示结果信息
                    this.TSSLState.Text = this.TSSLState.Text +
                                          "打开" + PublicVar.g_SCIComNum + "成功!" + "波特率选择：" + PublicVar.g_SCIBaudRate;
                    this.pictureBox1.Image = SerialPort.Properties.Resources.Run;
                }
                else//串口打开失败
                {
                    this.TSSLState.Text = this.TSSLState.Text +
                                          "打开" + PublicVar.g_SCIComNum + "失败!";
                    this.pictureBox1.Image = SerialPort.Properties.Resources.Run_static;
                }
            }
            else if (this.BtnSCISwitch.Text == "关闭串口(Close SCI)")
            {
                //提示当前操作
                this.TSSLState.Text = "过程提示:正在关闭串口...";
                //执行关闭串口操作,并用Flag返回结果
                Flag = sci.SCIClose(this.SCIPort);
                if (Flag == true)
                {
                    this.LblSCI.Text = str + PublicVar.g_SCIComNum
                             + "、" + PublicVar.g_SCIBaudRate + "\n" + msg;
                    this.BtnSCISwitch.Text = "打开串口(Open SCI)";
                    //[串口选择框]处于可用状态
                    this.CbSCIComNum.Enabled = true;
                    //[波特率选择框]处于可用状态
                    this.CbSCIBaud.Enabled = true;
                    this.TSSLState.Text += "关闭" + PublicVar.g_SCIComNum + "成功!";
                    this.pictureBox1.Image = SerialPort.Properties.Resources.Run_static;
                }
                else//串口关闭失败
                {
                    this.TSSLState.Text += "关闭" + PublicVar.g_SCIComNum + "失败!";
                }
            }
        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:BtnSCISend                                             
        /// 事    件:Click                                                  
        /// 功    能:发送数据:选择字符串发送时,以字符串的形式发送出去,      
        ///          选择十进制发送时,以十进制的形式发送                    
        ///          选择十六进制发送时,以十六进制的形式发送出              
        /// 函数调用:SCISendData:通过串口发送数据                           
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///-----------------------------------------------------------------
        private void BtnSCISend_Click(object sender, EventArgs e)
        {
            this.TSSLState.Text = "过程提示: 执行发送数据...";
            System.Collections.ArrayList SendData = new
                System.Collections.ArrayList();

            //如果串口没有打开
            if (!SCIPort.IsOpen)
            {
                //状态条进行提示
                this.TSSLState.Text += "请先打开串口!";
                return;
            }
        }
        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:BtnSCIClearSend                                        
        /// 事    件:Click                                                  
        /// 功    能:清除发送框中的内容                                     
        /// 函数调用:无                                                     
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///-----------------------------------------------------------------
        private void BtnSCIClearSend_Click(object sender, EventArgs e)
        {
            //this.TbSCISend.Text = "";
            this.TSSLState.Text = "过程提示:清空发送文本框!";
        }

        //=====================================================================
        //函数名：组帧
        //功  能：对串口中接受到的Flash中存储的图片数据进行组帧，
        //        并将其存入到数组中，进行图片还原。  
        //编程者：穆太力扑
        //日  期：2015/6/3
        //=====================================================================
        static int frameCount = 0;                  //组帧计数器
        static int myflag = 0;
        static byte a;
        public int CreatePicFrame(byte Data, byte[] buffer)
        {
            int frameFlag = 0;
            switch (frameCount)                     //根据静态变量frameCount组帧
            {
                case 0:                             //第一个数据
                    if (Convert.ToChar(Data) == '*') //收到数据是帧头FrameHead
                    {
                        frameCount++;
                        frameFlag = 0;        //组帧开始
                    }
                    break;
                case 1:                           //第二个数据，该数据是随后接收的数据个数
                    a = Data;
                    frameCount++;             //偏移量
                    break;
                case 2:
                case 3:
                case 4:
                    frameCount++;             //偏移量
                    break;
                default:                        //其他情况
                    {
                        try
                        {
                            //第二位数据是有效数据长度,根据它接收余下的数据直到帧尾前一位
                            if ((frameCount >= 5) && (frameCount <= a + 1))
                            {
                                buffer[250 * myflag + (frameCount - 5)] = Data;
                                frameCount++;
                                break;
                            }
                            //若是末尾数据则执行
                            if (frameCount >= (buffer[myflag * 256 + 1] + 2))
                            {
                                if (Convert.ToChar(Data) == '#')    //若是帧尾
                                {
                                    frameFlag = 1;    //组帧成功
                                    myflag++;
                                    //计数清0，准备重新组帧
                                    frameCount = 0;
                                }
                                break;
                            }
                        }
                        catch { }
                        break;
                    }
            }
            return frameFlag;
            //返回组帧状态
        }
        //=====================================================================
        //函数名：组帧
        //功  能：对串口中接受到的Flash中存储的图片数据进行组帧，
        //        并将其存入到数组中，进行图片还原。  
        //编程者：
        //日  期：2015/6/3
        //=====================================================================
        static int qitaCount = 0;                  //组帧计数器
        public int CreateFrame(byte Data, byte[] frameData)
        {
            int frameFlag = 0;

            switch (qitaCount)                     //根据静态变量frameCount组帧
            {
                case 0:                             //第一个数据
                    if (Convert.ToChar(Data) == '*')            //收到数据是帧头FrameHead
                    {
                        qitaCount++;
                        frameFlag = 0;        //组帧开始
                    }
                    break;
                case 1:                           //第二个数据，该数据是随后接收的数据个数
                    frameData[qitaCount - 1] = Data;
                    qitaCount++;
                    break;
                default:                        //其他情况
                    {
                        try
                        {
                            if (qitaCount <= frameData[0]+1)
                            {
                                frameData[qitaCount - 1] = Data;
                                qitaCount++;
                            }
                            else
                            {
                                frameFlag = 1;    //组帧成功
                                qitaCount = 0;
                            }
                        }
                        catch { }
                        break;
                    }
            }
            return frameFlag;
            //返回组帧状态
        }
        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:SCIPort                                                
        /// 事    件:DataReceived                                           
        /// 功    能:串口接收数据                                           
        /// 函数调用:(1)SCIReceiveData,串口接收函数                         
        ///          (2)SCIUpdateRevtxtbox,更新文本框中的内容               
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///-----------------------------------------------------------------
        byte[] Picture_ReceiveArry = new byte[5120];
        private void SCIPort_DataReceived(object sender,
            System.IO.Ports.SerialDataReceivedEventArgs e)
        {
            String str = String.Empty;
            bool Flag;//标记串口接收数据是否成功
            int len,en;//标记接收的数据的长度
            byte[] mFrameData = new byte[100];
            byte[] ch2 = new byte[2];

            Thread.Sleep(2000);
            //调用串口接收函数,并返回结果
            Flag = sci.SCIReceiveData(SCIPort, ref PublicVar.g_ReceiveByteArray);
            if (Flag == true)//串口接收数据成功
            {
                len = PublicVar.g_ReceiveByteArray.Length;
                //对于字符串形式,考虑到可能有汉字,
                //直接调用系统定义的函数,处理整个字符串
                str = Encoding.Default.GetString(PublicVar.g_ReceiveByteArray);
                SCIUpdateRevtxtbox(textBox1, str);
                for (int i = 0; i < len; i++)
                {
                    //开始组帧
                    if(len>100) 
                        en=CreatePicFrame(PublicVar.g_ReceiveByteArray[i], Picture_ReceiveArry);
                    else 
                        en = CreateFrame(PublicVar.g_ReceiveByteArray[i], mFrameData);
                    //if (en == 0) break;

                    //十进制都是按照三位来显示,字节之间有空格表示区分
                    //SCIUpdateRevtxtbox(textBox2,
                    //PublicVar.g_ReceiveByteArray[i].ToString("D3") + "  ");
                    //十六进制都是按照两位来显示,字节之间有空格表示区分
                    SCIUpdateRevtxtbox(textBox3,
                    PublicVar.g_ReceiveByteArray[i].ToString("X2") + "  ");
                }
                str = Encoding.Default.GetString(mFrameData);
                switch (str[1])
                {
                    case 'D':
                        SCIUpdateRevtxtbox(textBox9, str.Substring(2, mFrameData[0] - 1));
                        break;
                    case 'F':
                        byte[] tfloat = new byte[4];
                        float result1;
                        string fstr;
                        tfloat[0] = mFrameData[3];
                        tfloat[1] = mFrameData[4];
                        tfloat[2] = mFrameData[5];
                        tfloat[3] = mFrameData[6];
                        fstr = "";
                        result1 = BitConverter.ToSingle(tfloat, 0);
                        fstr = result1.ToString("F6");
                        SCIUpdateRevtxtbox(tBMCUR, fstr);
                        break;
                    case 'A':
                        try
                        {
                            float temper = (float)(25.0 - (mFrameData[2] * 3.3 * 1000 / 256 - 719) / 1.715);//将电压值转换为温度值  
                            string tem = temper.ToString("F1");
                            SCIUpdateRevtxtbox(textBox5, tem);
                        }
                        catch
                        { }
                        break;
                }
                
                this.TSSLState.Text = "过程提示:数据接收成功!";
            }
            //接收数据失败
            else
            {
                //sci.SCIReceInt(SCIPort, 1);//设置产生接收中断的字节数【2014-5-5 注释，否则会导致程序无响应】 
                this.TSSLState.Text = "过程提示:数据接收失败!";
            }

        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 函数名:SCIUpdateRevtxtbox                                       
        /// 参  数:(1)textbox,Object类型,接收数据要放入的文本框             
        ///        (2)text,string类型,要放入文本框的数据                    
        /// 功  能:若串行接收与Object不在同一线程中运行，那么通过invoke     
        ///        跨线程用串口接收到的数据来更新接收文本框中的数据         
        /// 返  回:无                                                       
        /// </summary>                                                      
        /// <param name="textbox"></param>                                  
        /// <param name="str"></param>                                      
        ///-----------------------------------------------------------------
        private void SCIUpdateRevtxtbox(Object textbox, string text)
        {
            //textbox显示文本与串口执行不在同一个线程中
            if (((TextBox)textbox).InvokeRequired)
            {
                handleinterfaceupdatedelegate InterFaceUpdate = new
                    handleinterfaceupdatedelegate(SCIUpdateRevtxtbox);
                this.Invoke(InterFaceUpdate, new object[] { textbox, text });
            }
            else
            {
                ((TextBox)textbox).Text += text;
                //把光标放在最后一行
                ((TextBox)textbox).SelectionStart =
                                           ((TextBox)textbox).Text.Length;
                //将文本框中的内容调整到当前插入符号位置
                ((TextBox)textbox).ScrollToCaret();
            }
        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:BtnSCIClearRec                                         
        /// 事    件:Click                                                  
        /// 功    能:清除接收文本框                                         
        /// 函数调用:无                                                     
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///-----------------------------------------------------------------
        private void btnClearRec_Click(object sender, EventArgs e)
        {
            //this.TbShowString.Text = string.Empty;
            //this.TbShowDec.Text = string.Empty;
            //this.TbShowHex.Text = string.Empty;
            this.TSSLState.Text = "过程提示:清空接收文本框!";
        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:TbSCISend                                              
        /// 事    件:KeyPress                                                 
        /// 功    能:限制发送框内输入数据的格式                             
        /// 函数调用:无                                                     
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///----------------------------------------------------------------- 
        private void TbSCISend_KeyPress(object sender, KeyPressEventArgs e)
        {
        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// /// 对    象:CbSCISendType                                          
        /// 事    件:SelectedIndexChanged                                   
        /// 功    能:当选泽发送方式时,提示用户输入数据的格式,并清空发送框   
        ///         (1)当选中"字符串方式(String)"时,提示用户"请输入字符串"  
        ///         (2)当选中"十进制方式(Decimal)"时,提示用户"请输入十进制数
        ///            ,以逗号隔开,数据范围0-255,允许用退格键"              
        ///         (3)当选中"十六进制方式(Hex):,提示用户"请输入十六进制数, 
        ///            以逗号隔开,数据范围00-FF,允许用退格键"               
        /// 函数调用:无                                                     
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///-----------------------------------------------------------------
        private void CbSCISendType_SelectedIndexChanged(object sender,
                                                        EventArgs e)
        {
        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:BtnState                                               
        /// 事    件:Click                                                  
        /// 功    能:控制状态条显示或隐藏                                   
        /// 函数调用:无                                                     
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///-----------------------------------------------------------------
        private void BtnState_Click(object sender, EventArgs e)
        {
            //状态条是不可见的
            if (this.TSSLState.Visible == false)
            {
                this.sSSerialPortInfo.Visible = true;//状态条可见
                BtnState.Text = "隐藏状态条(Hide)";
            }
            //当前状态条不可见
            else
            {
                this.sSSerialPortInfo.Visible = false;//状态条不可见
                BtnState.Text = "显示状态条(Show)";
            }
        }

        ///-----------------------------------------------------------------
        /// <summary>                                                       
        /// 对    象:FrmSCI                                                 
        /// 事    件:FormClosing                                               
        /// 功    能:关闭窗体时,确保串口已经关闭                            
        /// 函数调用:SCIClose                                               
        /// </summary>                                                      
        /// <param name="sender"></param>                                   
        /// <param name="e"></param>                                        
        ///-----------------------------------------------------------------
        private void FrmSCI_FormClosing(object sender,
            FormClosingEventArgs e)
        {
            try
            {
                sci.SCIClose(SCIPort);
            }
            catch
            {
            }
        }

        //四则运算
        private void button1_Click(object sender, EventArgs e)
        {
            byte[] SendByteArray = new byte[16];      //总长
            float dbx, dby, result=0.0f;
            byte[] bchar = new byte[4];
            dbx = float.Parse(tBX.Text);
            dby = float.Parse(tBY.Text);
            tBMCUR.Text = "";
            //赋值
            SendByteArray[0] = (byte)'*';         //帧头
            SendByteArray[1] = 10;                 //数据长度
            SendByteArray[2] = (byte)'F';
            //tBX:
            bchar = BitConverter.GetBytes(dbx);
            SendByteArray[4] = bchar[0];
            SendByteArray[5] = bchar[1];
            SendByteArray[6] = bchar[2];
            SendByteArray[7] = bchar[3];
            //tBY:
            bchar = BitConverter.GetBytes(dby);
            SendByteArray[8] = bchar[0];
            SendByteArray[9] = bchar[1];
            SendByteArray[10] = bchar[2];
            SendByteArray[11] = bchar[3];
            SendByteArray[12] = (byte)'#';
            if (m == 0)                               //判断运算符，m=0为加法运算
            {
                SendByteArray[3] = (byte)'A';         //操作命令
                result = dbx + dby;
            }
            else if (m == 1)                               //判断运算符，m=1为减法运算
            {
                SendByteArray[3] = (byte)'S';         //操作命令
                result = dbx - dby;
            }
            else if (m == 2)                               //判断运算符，m=2为乘法运算
            {
                SendByteArray[3] = (byte)'M';         //操作命令
                result = dbx * dby;

            }
            else if (m == 3)                               //判断运算符，m=3为除法运算
            {
                SendByteArray[3] = (byte)'D';         //操作命令
                result = dbx / dby;
            }
            tBPCR.Text = result.ToString("F6");
            if (SCIPort.IsOpen == true)
            {
                SCIPort.Write(SendByteArray, 0, 13);
                Thread.Sleep(200);
            }
        }
        static int m = 0;//判断运算符标志
        private void comboBox1_SelectedIndexChanged_1(object sender, EventArgs e)
        {
            m = comboBox1.SelectedIndex;
        }
       
        private void button2_Click(object sender, EventArgs e)//擦除
        {
            byte[] bLen = BitConverter.GetBytes(jpgLen);
            byte[] SendByteArray23 = new byte[] { (byte)'*', 5, (byte)'E', 0,0,0,0,(byte)'#' };
            SendByteArray23[3] = bLen[0];
            SendByteArray23[4] = bLen[1];
            SendByteArray23[5] = bLen[2];
            SendByteArray23[6] = bLen[3];
            if (SCIPort.IsOpen == true)
            {
                SCIPort.Write(SendByteArray23, 0, 8);
            }
            this.TSSLState.Text = "过程提示:擦除Flash中数据";
        }

        public byte[] PictureToByte(string imagePath)//图片转换字节
        {
            FileStream fs = new FileStream(imagePath, FileMode.Open);
            byte[] byteData = new byte[fs.Length];
            fs.Read(byteData, 0, byteData.Length);
            fs.Close();
            return byteData;
        }
        public System.Drawing.Image ByteToPicture(byte[] streamByte)//字节转换图片
        {
            System.IO.MemoryStream ms;
            System.Drawing.Image img = null ;
            try
            {
                ms = new System.IO.MemoryStream(streamByte);
                img = System.Drawing.Image.FromStream(ms);
            }
            catch { }
            return img;
        }
        private void button3_Click(object sender, EventArgs e)//写入Flash
        {
            //定义组帧数组
            byte[][] SendByteArray = new byte[jpgLen / 250 + 1][];
            // Create the jagged array 
            for (int i = 0; i < SendByteArray.Length; i++)
            {
                SendByteArray[i] = new byte[256];
            } 
            
            //读取磁盘上的图片
            int a = PictureToByte("1.jpg").Length;
            byte[] picture_byte = new byte[a];
            picture_byte = PictureToByte("1.jpg");

            //----------------------------------开  始  组  帧--------------------------------------
            for (int  i = 0; i <= (jpgLen / 250 ); i++)
            {
                SendByteArray[i][0] = (byte)'*';          //帧头
                SendByteArray[i][1] = 253;                //帧长
                SendByteArray[i][2] = (byte)'W';          //操作符
                SendByteArray[i][3] = (byte)('A' + i/4);  //扇区号
                SendByteArray[i][4] = (byte)('0' + i%4);  //偏移量
                SendByteArray[i][255] = (byte)'#';        //帧尾
            }
            
            for (int i = 0; i < (jpgLen / 250); i++)
            {
                for (int j = 0; j < 250; j++)
                    SendByteArray[i][j + 5] = picture_byte[ i * 250 + j];//数据
            }
            
            for (int i = (jpgLen / 250),j = 0; j < (jpgLen-i*250); j++)
                SendByteArray[i][j + 5] = picture_byte[ i * 250 + j];//数据

            for (int i = (jpgLen / 250), j = (jpgLen - i * 250); j < 250; j++)
                SendByteArray[i][j + 5] = (byte)255;//数据
            
                
            if (SCIPort.IsOpen == true)//串口发送
            {
                for (int i = 0; i <= (jpgLen / 250 ); i++)
                {
                    SCIPort.Write(SendByteArray[i], 0, 256);
                    Thread.Sleep(200);
                }
            }
            this.TSSLState.Text = "过程提示:数据写入Flash中";
        }

        int Read_flag = 0;
        private void button4_Click(object sender, EventArgs e)//从Flash读取
        {
            byte[] bLen = BitConverter.GetBytes(jpgLen);
            byte[] SendByteArray23 = new byte[] { (byte)'*', 5, (byte)'R', 0, 0, 0, 0, (byte)'#' };
            SendByteArray23[3] = bLen[0];
            SendByteArray23[4] = bLen[1];
            SendByteArray23[5] = bLen[2];
            SendByteArray23[6] = bLen[3];
            if (SCIPort.IsOpen == true)
            {
                SCIPort.Write(SendByteArray23, 0, 8);
            }
            Read_flag = 1;
            t = 0;
            pictureBox3.Image = ByteToPicture(bLen);
            this.TSSLState.Text = "过程提示：读取Flash中数据";


        }

        int t = 0;
        static double temp = 0;
        //刷新图片
        private void timer1_Tick(object sender, EventArgs e)
        {
            if (SCIPort.IsOpen == true && Read_flag == 1)
            {
                t++;
                if (t % 2 == 0)
                {
                    label6.Text = "读取图片中...";
                }
                else
                {
                    label6.Text = "读取图片中.";
                }
                if (t > 10)
                {
                    label6.Text = "";
                    pictureBox3.Image = ByteToPicture(Picture_ReceiveArry);
                    
                }
            }
            if (SCIPort.IsOpen == true)
            {
                temp++;            
            }
        }


        private void button7_Click_1(object sender, EventArgs e)
        {
            byte[] SendByteArray = new byte[6];
            SendByteArray[0] = (byte)'*';         //帧头
            SendByteArray[1] = 2;                 //数据长度
            SendByteArray[2] = (byte)'L';
            SendByteArray[3] = (byte)'R';         //操作命令
            SendByteArray[4] = (byte)'#';
            if (SCIPort.IsOpen == true)
            {
                SCIPort.Write(SendByteArray, 0, 5);
            }
        }

        private void button6_Click_1(object sender, EventArgs e)
        {
            byte[] SendByteArray = new byte[6];
            SendByteArray[0] = (byte)'*';         //帧头
            SendByteArray[1] = 2;                 //数据长度
            SendByteArray[2] = (byte)'L';
            SendByteArray[3] = (byte)'B';         //操作命令
            SendByteArray[4] = (byte)'#';
            if (SCIPort.IsOpen == true)
            {
                SCIPort.Write(SendByteArray, 0, 5);
            }
        }

        private void button5_Click_1(object sender, EventArgs e)
        {
            byte[] SendByteArray = new byte[6];
            SendByteArray[0] = (byte)'*';         //帧头
            SendByteArray[1] = 2;                 //数据长度
            SendByteArray[2] = (byte)'L';
            SendByteArray[3] = (byte)'G';         //操作命令
            SendByteArray[4] = (byte)'#';
            if (SCIPort.IsOpen == true)
            {
                SCIPort.Write(SendByteArray, 0, 5);
            }
        }

        private void button8_Click(object sender, EventArgs e)
        {
            byte[] SendByteArray = new byte[6];
            SendByteArray[0] = (byte)'*';         //帧头
            SendByteArray[1] = 2;                 //数据长度
            SendByteArray[2] = (byte)'L';
            SendByteArray[3] = (byte)'Q';         //操作命令
            SendByteArray[4] = (byte)'#';
            if (SCIPort.IsOpen == true)
            {
                SCIPort.Write(SendByteArray, 0, 5);
            }
        }

        private void button9_Click(object sender, EventArgs e)
        {
            byte[] SendByteArray = new byte[6];
            SendByteArray[0] = (byte)'*';         //帧头
            SendByteArray[1] = 2;                 //数据长度
            SendByteArray[2] = (byte)'L';
            SendByteArray[3] = (byte)'O';         //操作命令
            SendByteArray[4] = (byte)'#';
            if (SCIPort.IsOpen == true)
            {
                SCIPort.Write(SendByteArray, 0, 5);
            }
        }

        private void button10_Click(object sender, EventArgs e)
        {
            byte[] SendByteArray = new byte[6];
            SendByteArray[0] = (byte)'*';         //帧头
            SendByteArray[1] = 2;                 //数据长度
            SendByteArray[2] = (byte)'A';
            SendByteArray[3] = (byte)'p';         //操作命令
            SendByteArray[4] = (byte)'#';
            if (SCIPort.IsOpen == true)
            {
                SCIPort.Write(SendByteArray, 0, 5);
            }
            this.textBox5.Text = "";
        }

        private void button12_Click(object sender, EventArgs e)
        {
            char cmd1 = char.Parse(this.comboBox2.Text.Trim().Substring(0, 1));
            byte cmd2 = byte.Parse(this.textBox7.Text.Trim());
            byte cmd3 = byte.Parse(this.textBox8.Text.Trim());
            byte[] SendByteArray = new byte[6];
            byte cmd4 = byte.Parse(this.textBox2.Text.Trim());
            byte[] cmd5 = Encoding.Default.GetBytes(this.textBox9.Text.Trim());
            switch (cmd1)
            {

                case 'S'://删除flash扇区中数据
                    SendByteArray[0] = (byte)'*';      //帧头
                    SendByteArray[1] = 3;              //帧长度
                    SendByteArray[2] = (byte)cmd1;     //操作命令
                    SendByteArray[3] = cmd2;           //起始扇区
                    SendByteArray[4] = cmd3;           //扇区数量
                    SendByteArray[5] = (byte)'#';

                    if (SCIPort.IsOpen == true)
                    {
                        SCIPort.Write(SendByteArray, 0, 6);
                    }
                    break;
                   
                case 'X'://写数据入flash中
                    cmd4 = (byte)(this.textBox9.Text.Length);
                    this.textBox2.Text = cmd4.ToString();
                    SendByteArray = new byte[7+cmd4];
                    SendByteArray[0] = (byte)'*';       //帧头
                    SendByteArray[1] = (byte)(4 + cmd4);               //帧长度
                    SendByteArray[2] = (byte)cmd1;      //操作命令
                    SendByteArray[3] = cmd2 ;           //起始扇区
                    SendByteArray[4] = cmd3 ;           //偏移量
                    SendByteArray[5] = cmd4 ;           //字符数量
                    for(int i=0;i<cmd4;i++)
                       SendByteArray[6+i] = cmd5[i] ;           //字符数量
                    SendByteArray[6 + cmd4] = (byte)'#';
                    if (SCIPort.IsOpen == true)
                    {
                        SCIPort.Write(SendByteArray, 0, 7+cmd4);
                    }
                    break;
                case 'D'://读flash中数据显示
                    SendByteArray = new byte[7];
                    SendByteArray[0] = (byte)'*';       //帧头
                    SendByteArray[1] = 4;               //数据长度
                    SendByteArray[2] = (byte)cmd1;      //操作命令
                    SendByteArray[3] = cmd2 ;           //起始扇区
                    SendByteArray[4] = cmd3 ;           //偏移量
                    SendByteArray[5] = cmd4 ;           //字符数量
                    SendByteArray[6] = (byte)'#';
                    if (SCIPort.IsOpen == true)
                    {
                        SCIPort.Write(SendByteArray, 0, 7);
                    }
                    break;
            }
            
        }

        static string strBox2 = "18";
        private void comboBox2_SelectedIndexChanged(object sender, EventArgs e)
        {
            label14.Text = "起始扇区";
            strBox2 = textBox7.Text;
            switch (char.Parse(this.comboBox2.Text.Substring(0, 1)))
            {
                case 'S':
                    label15.Text = "扇区数";
                    textBox7.Text = strBox2;
                    textBox8.Text = "1";
                    label3.Visible = false;
                    textBox2.Visible = false;
                    label16.Visible = false;
                    textBox9.Visible = false;
                    break;
                case 'X':
                    textBox7.Text = strBox2;
                    textBox8.Text = "0";
                    label15.Text = "偏移量";
                    label3.Visible = true;
                    label3.Text = "字符数量";
                    textBox2.Visible = true;
                    textBox2.Text = "4";
                    label16.Visible = true;
                    label16.Text = "写入数据：";
                    textBox9.Visible = true ;
                    textBox9.Text = "1234";
                    break;
                case 'D':
                    label15.Text = "偏移量";
                    textBox7.Text = strBox2;
                    label3.Visible = true;
                    label3.Text = "字符数量";
                    textBox2.Visible = true;
                    label16.Visible = true;
                    label16.Text = "读取数据：";
                    textBox9.Visible = true;
                    textBox9.Text = "";
                    break;
            }
        }
        private void textBox8_TextChanged(object sender, EventArgs e)
        {
            try
            {
                if (label15.Text == "偏移量")
                {
                    if ((int.Parse(this.textBox8.Text) % 4) != 0)
                    {
                        MessageBox.Show("只能输入4的倍数的偏移量");
                    }
                }
            }
            catch
            {
            }

        }        
    }
}
